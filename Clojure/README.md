## Labs for Modern Programming Methods course in NSU

Материалы лекций доступны в Google Classroom.

Язык и документация:
http://clojure.org

Online:
https://repl.it/languages/clojure

Рекомендуемая среда разработки:
Eclipse + CounterClockwise plugin
https://github.com/ccw-ide/ccw/wiki/GoogleCodeHome

Сборка:
Leiningen + Apache Maven
http://leiningen.org/

## 1. Базовые операции над структурами данных

Общее условие:  
Задан набор символов и число n. Опишите функцию, которая возвращает список всех строк длины n,
состоящих из этих символов и не содержащих двух одинаковых символов, идущих подряд.

Пример:  
Для символов 'а', 'b', 'c' и n=2 результат должен быть ("ab" "ac" "ba" "bc" "ca" "cb") с точностью до
перестановки.

**1.1.** Решите задачу с помощью элементарных операций над константами и списками (`str`, `cons`, `concat` и т.п.) и рекурсии.  
**1.2.** Перепишите программу **1.1.** так, чтобы все рекурсивные вызовы были хвостовыми.  
**1.3.** Определить функции `my-map` и `my-filter`, аналогичные `map` (для одного списка) и `filter`, выразив их через `reduce` и базовые операции над списками (`cons`, `first`, `concat` и т.п.)  
**1.4.** Решите задачу **1.1./1.2.** с использованием `map/reduce/filter` вместо рекурсивных вызовов. 


## 2. Численное интегрирование

Общее условие:  
Реализовать функцию (оператор), принимающую аргументом функцию от одной переменной `f` и возвращающую функцию одной переменной, вычисляющую (численно) выражение $\int\limits_0^x f(t)\mathrm{d}t$. 

Можно использовать метод трапеций с постоянным шагом.  
При оптимизации исходить из того, что полученная первообразная будет использоваться для построения графика (т.е. вызываться многократно в разных точках). 

**2.1.** Оптимизируйте функцию с помощью мемоизации.  
**2.2.** Оптимизируйте функцию с помощью бесконечной последовательности частичных решений. 

Показать прирост производительности с помощью `time`.


## 3. Параллельная обработка последовательностей

**3.1.** Реализуйте параллельный вариант `filter` (не обязательно ленивый) с помощью `future`.
- Параллельная обработка должна производиться блоками по заданному числу элементов.
- Размер блоков следует вычислять вручную, без использования готовых функций, таких как `partition`  
(для разделения последовательности следует использовать `take` и `drop`).  
- Продемонстрируйте прирост производительности в сравнении с обычным фильтром.  

**3.2.** Реализуйте ленивый параллельный filter, который должен работать в том числе с бесконечными
потоками. 
- Продемонстрируйте прирост производительности в сравнении с обычным фильтром.


## 4. ДНФ

- По аналогии с задачей дифференцирования реализовать представление символьных булевых
выражений с операциями конъюнкции, дизъюнкции отрицания, импликации. Выражения могут
включать как булевы константы, так и переменные.
- Реализовать подстановку значения переменной в выражение с его приведением к ДНФ.
- Обеспечить расширяемость для новых операций (исключающее ИЛИ, стрелка Пирса и пр.)
- Код должен быть покрыт тестами, API документирован.

## 5. Проект – [Representing data in S-expressions](https://github.com/Pirchesko/nsu-clojure-s-expressions)

Представление данных в S-выражениях

Требования:

**1.** Определите формат представления данных с древовидной структурой в виде S-
выражений. В качестве семантической основы рекомендуется рассмотреть форматы 
XML и/или JSON. Допускается использование как классических S-выражений, так и
расширенных, используемых в языке Clojure.
**2.** Разработайте язык навигации и простых запросов для заданного формата. Должны
поддерживаться: относительный или абсолютный путь к узлу дерева, путь с
условиями на свойства промежуточных узлов, путь с переменной вложенностью. В
качестве семантической основы рекомендуется рассмотреть язык XPath для XML.
Реализуйте функции поиска и модификации заданного формата посредством этого
языка.
**3.** Разработайте представление схемы (по аналогии с XML Schema). Реализуйте функции
проверки документа по схеме.

Дополнительные требования:

**4.** Разработайте язык трансформации в HTML, как упрощенный аналог XSLT.
**5.** Реализуйте модель разбора по аналогии с XML SAХ, обеспечьте поддержку
трансформации и валидации по схеме в этом режиме.

Рекомендации:

Ознакомьтесь XML-технологиями (SAX, DOM, XML Schema, XPath, XSLT)
