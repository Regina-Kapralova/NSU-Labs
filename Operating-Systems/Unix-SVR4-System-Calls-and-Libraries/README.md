## Операционные системы: Системные вызовы и библиотеки Unix SVR4
(Бакалавриат, 4-й семестр)

## Раздел 1. Среда исполнения.

**1. Вывод различных атрибутов процесса в соответствии с указанными опциями.**  

Напишите программу, которая будет обрабатывать опции, приведенные ниже. Опции должны быть 
обработаны в соответствии с порядком своего появления справа налево. Одной и той же опции 
разрешено появляться несколько раз. Используйте `getopt(3C)` для определения имеющихся опций. 
Сначала пусть ваша программа обрабатывает только некоторые опции. Затем добавьте еще, до тех 
пор, пока все требуемые опции не будут обрабатываться. Вы можете скопировать воспользоваться 
программой `getopt_ex.c` и изменить ее.

- `-i`  Печатает реальные и эффективные идентификаторы пользователя и группы.
- `-s`  Процесс становится лидером группы. Подсказка: смотри `setpgid(2)`.
- `-p`  Печатает идентификаторы процесса, процесса-родителя и группы процессов.
- `-u`  Печатает значение `ulimit`.
- `-Unew_ulimit`  Изменяет значение `ulimit`. Подсказка: смотри `atol(3C)` на странице руководства `strtol(3C)`.
- `-c`  Печатает размер в байтах core-файла, который может быть создан.
- `-Csize`  Изменяет размер core-файла.
- `-d`  Печатает текущую рабочую директорию.
- `-v`  Распечатывает переменные среды и их значения.
- `-Vname=value`  Вносит новую переменную в среду или изменяет значение существующей переменной.
 
Проверьте вашу программу на различных списках аргументов, в том числе:
- Нет аргументов.
- Недопустимую опцию.
- Опции, разделенные знаком минус.
- Неудачное значение для `U`.

**2. Время в Калифорнии.**  

Напишите программу, которая выводит дату и время в Калифорнии (Pacific Standard Time, PST).
Подсказка: если время UTC 20 часов, то в Калифорнии 12 часов.

**3. Установка идентификатора пользователя для доступа к файлу.**  

Создайте файл данных, который может писать и читать только владелец (это можно сделать командой `shell chmod 600 file`) 
и напишите программу, которая
- Печатает реальный и эффективный идентификаторы пользователя.
- Открывает файл с помощью `fopen(3)`. Если `fopen()` завершился успешно, файл должен быть закрыт с помощью `fclose(3)`.
Напечатайте сообщение об ошибке, используя `perror(3C)`, если файл не удалось открыть.
- Сделайте, чтобы реальный и эффективный идентификаторы пользователя совпадали. Подсказка: `setuid(2)`.
- Повторите первые два шага.
 
Проверьте работу вашей программы.
- Исполните программу и посмотрите вывод.
- Сделайте программу доступной для запуска членам вашей группы, и пусть ваши одногруппники исполнят программу.
- Командой `chmod u+s prog` установите бит установки идентификатора пользователя и пусть ваши одногруппники опять исполнят эту программу.

## Раздел 1. Управление памятью.

**4. Список строк.**  

Напишите программу, которая вставляет строки, введенные с клавиатуры, в список. Память под узлы списка выделяйте динамически 
с использованием `malloc(3)`. Ввод завершается, когда в начале строки вводится точка `.`. Затем все строки из списка выводятся на экран.  

Подсказка: Объявите массив символов размера, достаточного чтобы вместить самую длинную введенную строку. 
Используйте `fgets(3)`, чтобы прочитать строку, и `strlen(3)`, чтобы определить ее длину. Помните, что `strlen(3)`
не считает нулевой символ, завершающий строку. После определения длины строки, выделите блок памяти нужного размера 
и внесите новый указатель в список.  

При сдаче этой программы на С++ запрещается использовать `std::string` и контейнеры STL для реализации списка. 

## Раздел 1. Системные вызовы ввода/вывода.

**5. Таблица поиска строк в текстовом файле.**  

Написать программу, которая анализирует текстовый файл, созданный текстовым редактором, таким как `ed(1)` или `vi(1)`. 
После запроса, который предлагает ввести номер строки, с использованием `printf(3)` программа печатает соответствующую строку текста. 
Ввод нулевого номера завершает работу программы. Используйте `open(2)`, `read(2)`, `lseek(2)` и `close(2)` для ввода/вывода. 
Постройте таблицу отступов в файле и длин строк для каждой строки файла. Как только эта таблица построена, 
позиционируйтесь на начало заданной строки и прочтите точную длину строки. 

Подсказка: Выберите или создайте текстовый файл с короткими строками. Помните, что первая строка начинается с нулевого отступа в файле. 
Найдите каждый символ перевода строки, запишите его позицию; в программе следует использовать вызов `lseek(fd, 0L, 1)`. 
Для отладки распечатайте эту таблицу и сравните с таблицей, полученной вручную. Как только таблицы начнут совпадать, 
можно приступать к запросу номера строки.

**6. Таблица поиска строк в текстовом файле (при использовании alarm).**  

Измените программу так, чтобы пользователю отводилось 5 секунд на ввод номера строки. 
Если пользователь не успевает, программа должна распечатать все содержимое файла и завершиться. Если же пользователь успел 
в течение пяти секунд ввести номер строки, то программа должна работать как в предыдущей задаче.

## Раздел 1. Создание пpоцессов и исполнение пpогpамм. Управление процессами.

**9. Создание двух процессов.**  

Напишите программу, которая создает подпроцесс. Этот подпроцесс должен исполнить `cat(1)` длинного файла. 
Родитель должен вызвать `printf(3)` и распечатать какой-либо текст. После выполнения первой части задания модифицируйте 
программу так, чтобы последняя строка, распечатанная родителем, выводилась после завершения порожденного процесса. 
Используйте `wait(2)`, `waitid(2)` или `waitpid(3)`.

**10. Код завершения команды.**  

Напишите программу, которая запускает команду, заданную в качестве первого аргумента, в виде порожденного процесса. 
Все остальные аргументы программы передаются этой команде. Затем программа должна дождаться завершения порожденного 
процесса и распечатать его код завершения.

**11. Функция execvpe().**  

Напишите функцию `execvpe()`, которая работает как `execvp(2)`, но позволяет изменять среду исполнения, как `execve(2)`.

Подсказка: используйте внешнюю переменную `environ`.

## Раздел 2. Программные каналы.

**25. Связь через программный канал.**  

Напишите программу, которая создает подпроцесс, взаимодействующий с родителем через программный канал. 
Один из процессов выдает в канал текст, состоящий из символов верхнего и нижнего регистров. Второй процесс переводит 
все символы в верхний регистр, и выводит полученный текст на терминал. 

Подсказка: смотри `toupper(3)`.

**26. Связь с использованием функций стандартной библиотеки.**  

Используйте стандартные библиотечные функции `popen(3)` и `pclose(3)` для выполнения тех же операций, что и в предыдущем упражнении.

**27. Подсчет пустых строк в файле.**  

Напишите программу, которая подсчитывает пустые строки в файле, используя команду `wc(1)`.

**28. Генератор случайных чисел.**  

Измените ваш командный интерпретатор так, чтобы он позволял создавать конвейеры. Если вы добавили управление заданиями в 
упражнениях Раздела 1, вы можете модифицировать программу так, чтобы все процессы в конвейере принадлежали к одной группе. 
Тогда, например, `SIGINT` мог бы прервать все процессы в конвейере первого плана.
